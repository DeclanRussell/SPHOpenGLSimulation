<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>SPH Water Simulation: SPH Water Simulation by Declan Russll</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SPH Water Simulation
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">SPH water simulation created by Declan Russell</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">SPH Water Simulation by Declan Russll </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="image">
<img src="Sim.png" alt="Sim.png"/>
</div>
  
  <b><u>Installation</u></b><br>
   This program should run pretty much out of the box, just rebuild all once you boot up the project and click run!<br/>
  
  <b><u>Controles</u></b><br>
   Space - play/pause our simulation <br/>
 1 - toggle drawing of the mesh <br/>
 2 - toggle drawing of the particles <br/>
 3 - toggle between our mesh simulation and my brand new 2d simulation! <br/>
 Left click - Rotate the scene <br/>
 Right click - Pan the scene<br/>
 Ctrl + Left click - Move the external force postion. You can click and drag with this<br/>
 +/- - increase and decrease the strength of the external force<br/>
 0/9 - increase and decrease the radial influence of the external force. Note this force has linear falloff<br/>
 E - toggle the force between pushing and sucking<br/>
 R - restart the simulation<br/>
 Feel free to change the input mesh, just change the modelLocation in <a class="el" href="classNGLScene.html#a63e57fc201b639e51c6eed6ec3b6b992" title="the initialize class is called once when the window is created and we have a valid GL context use thi...">NGLScene::initialize()</a><br/>
  
  <b><u>Research</u></b><br>
   Navier Stokes Equations<br/>
 The over all Navier stokes euquation goes as follows,<br/>
 </p>
<div class="image">
<img src="NavierStokesComplete.png" alt="NavierStokesComplete.png"/>
</div>
<p> This calculates the acceleration of a particle. Now although this may look quite complicated we can break it down into 3 main parts.<br/>
 <br/>
 The Density of the particle<br/>
 </p>
<div class="image">
<img src="CalcDensity.png" alt="CalcDensity.png"/>
</div>
<p> In the equation xi is the position of the particle that we wish to find the density for. So to find the density for this particle we sum together the mass of neighbouring particles j multiplied by weighting kernal W.<br/>
 What is a weighting kernal?<br/>
 The weighting kernal determins the influence each particle has one each other. For instance if 2 particle are very close, then the influence will be very high. Alternativly if the two particles are very far away from each other they will have very low or zero influence on each other.<br/>
 <br/>
 Calculateing the weighting kernal<br/>
 </p>
<div class="image">
<img src="DensityWeightingKern.png" alt="DensityWeightingKern.png"/>
</div>
<p> In this equation there are 2 variables.<br/>
 'r' This is the distance between the particle we are calculating density for and the neighbouring particle we are sampling.<br/>
 'h' this is our smoothing length. This ultimately determins the distance in which the particles continue to have infulence. You can see this from the limitations in our W default equation. If r &gt; h then we will return 0 and this particle will have no influence.</p>
<p>The Pressure gradient<br/>
 </p>
<div class="image">
<img src="CalcPressureGrad.png" alt="CalcPressureGrad.png"/>
</div>
<p> This is the pressure gradient, this indicates the direction of pressure and how dtring it is. If the pressure is negative then there is a sucking force, alternatively is positive then it is a pushing force. This equation is slightly more complicated that the previous but again if we split it up it becomes much easier to handle. We'll start with the part in the brackets. The p stands for pressure, pi is the pressure of the particle that we are calculating for and pj is the neighbouring particle that we are sampling. But how do we calculate the pressure you may ask?<br/>
 </p>
<div class="image">
<img src="PressPerParticle.png" alt="PressPerParticle.png"/>
</div>
<p> This euqation calculates the pressure per particle. Row (the p shaped letter) stands for density. Rowi is our current density and Row0 is the resting density of our particle. k is a gas constant which we can change depending on what fluid we are trying to imitate.<br/>
 Moving onto the next part of the pressure equation we have mj which is simply the mass of our neighbouring particle, multiplied by another weighting kernal. <br/>
 Calculating the pressure wighting kernal<br/>
 </p>
<div class="image">
<img src="PressureWeightingKern.png" alt="PressureWeightingKern.png"/>
</div>
<p> As you can see this weighting kernal is very similar to our density one. 'r' is still the distance between particles and 'h' is still our smoothing length. Notice the Wdefault, this means that we still have the same limitations that we did in our density kernal.<br/>
 The Viscosity Term<br/>
 </p>
<div class="image">
<img src="CalcViscTerm.png" alt="CalcViscTerm.png"/>
</div>
<p> The Viscosity in simple terms influences particles to flow in the same direction. If a large amount of particles are moving in one direction others should follow them.<br/>
 Lets break this equation down. Firstly we have meu, this represents our viscosity coeficitent, a scaler to our viscosity equation. This can be changed depending on what liquid we are trying to imitate. Next 'u', this is the velocity of a particle. (uj - ui) is the vector from our currents particles velcity to our neighbours. 'm' we already know as mass and 'Row' we know as the density. Finally we have our third and final weighting kernal. <br/>
 Calculating the viscosity weighting kernal<br/>
 </p>
<div class="image">
<img src="ViscWeightKern.png" alt="ViscWeightKern.png"/>
</div>
<p> Just like before we have 'r' the distance between particles and 'h' our smoothing length. Once again we just pump in these values to calculate the influence weight of this particle.<br/>
 Any External Forces<br/>
 </p>
<div class="image">
<img src="Forces.png" alt="Forces.png"/>
</div>
<p> External forces in this simulation can be things such as gravity or wind. In my simulation I have used this to create a external force to interact with the fluid from mouse clicks.<br/>
 <br/>
  
  <u>Integration</u><br>
   As you can see the Navier stokes equations calculate the acceleration of our particles. From this we can use the time step between updates to calcute our velcocity and our postion of our particles. The first itegrator I used was simple Euler euqations, </p>
<div class="image">
<img src="EulerInt.png" alt="EulerInt.png"/>
</div>
<p> Here we have 2 equations, the first to calculate 'u' our velocity for a particle. This uses 'a' our calculated acceleration and delta(the d) t, which represents the change in time. The second equation calculates 'x' our postion in a similar way. Also though these euqations are acurate in real world physics, for our simulations they will create large errors due to the delay between updating each particle. So we must use another method.<br/>
 </p>
<div class="image">
<img src="LeapFrog1.png" alt="LeapFrog1.png"/>
</div>
 <div class="image">
<img src="LeapFrog2.png" alt="LeapFrog2.png"/>
</div>
<p> This is the Leap Frog integration method. It works by using future half step velocities to calculate a more accurate value for position. To calculate the actual velocity at a point in time from these half step velocies we must use a forth equation. </p>
<div class="image">
<img src="LeapFrog3.png" alt="LeapFrog3.png"/>
</div>
<p> This uses our half back velocity and our half forward to calculate our final particle velocity. <br/>
  
  <u>Optimisations</u><br>
   For this simulation, for us to achieve a respectable frame rate we are going to have to sacrifice some accuracy in our equations. The Navier Stokes equations in real life implementation need to sample every point in exsistance to find the true acceleration of one particle. For our simulation this creates a colexity of O(n^2) which is far too slow! To optimize our simulation, to calculate the acceleration for one particle we should only sample a few particles that lie close to that particle as sampling thousands of particle that have no infulence on a particle is redundant and wastes cpu time.<br/>
 <br/>
 How to find our neighbours - The Spatial Hash<br/>
 To find the neighbouring particles from one particle we will use a hash function. This will generate a key based on the position of a particle and store it in a table. Particles with a similar position will have the same key assigned to them. Then all we need to do is seach for particles with the same key to find our neighbouring particles. </p>
<div class="image">
<img src="SpatialHash1.png" alt="SpatialHash1.png"/>
</div>
<p> This is the spatial hash function that we are going to use to generate the keys based on our particles position. Yes this may look complicated but lets break it up again. The x with the hat on is a function that takes in a vector of floating point numbers and returns an integer based on cell size l. </p>
<div class="image">
<img src="SpatialHash2.png" alt="SpatialHash2.png"/>
</div>
<p> For our simulation we can just set cell size l to the smoothing length of our Navier Stokes equations.<br/>
 Back to our original hash function notice we have three variables p1, p2, and p3. These are just very large prime numbers which in our simulation are,<br/>
 p1 = 73,856,093<br/>
 p2 = 19,349,663<br/>
 p3 = 83,492,791<br/>
</p>
<p>The final unknown in our equation is nh. This is the size of our hash table and is calculated with the following formulae </p>
<div class="image">
<img src="HashTableSize.png" alt="HashTableSize.png"/>
</div>
<p> Note the prime is just an equation to find the next prime number from an input number. Which is done with this piece of code,<br/>
<br/>
 int nextPrimeNum(int _currentNum){<br/>
 int nextPrime = _currentNum;<br/>
 bool Prime = false;<br/>
 if(_currentNum&lt;=0){<br/>
 std::cerr&lt;&lt;"The number input is less than or equal to zero"&lt;&lt;std::endl;<br/>
 return 1;<br/>
 }<br/>
 if(_currentNum==2){<br/>
 return 2;<br/>
 }<br/>
 if((_currentNum % 2 ) == 0){<br/>
 nextPrime+=1;<br/>
 }<br/>
 while(!Prime){<br/>
 Prime = true;<br/>
 for(int i = 3; i&lt;sqrt(nextPrime); i+=2){<br/>
 if((nextPrime % i)==0){<br/>
 Prime = false;<br/>
 }<br/>
 }<br/>
 if(!Prime){<br/>
 nextPrime+=2;<br/>
 }<br/>
 }<br/>
 return nextPrime;<br/>
 }<br/>
 <br/>
  
  <b><u>Implementation</u></b><br>
   <div class="image">
<img src="UML.png" alt="UML.png"/>
</div>
<p> Here is the class diagram for my simulation. The main class is our <a class="el" href="classSPHMelt.html" title="Our main simulation class. Used to call all the other classes we have created. ">SPHMelt</a> class, this handles spawning all of our particles into our scene then putting them into our <a class="el" href="classSPHHash.html" title="Our hash class. this class will hash particles based on their position and return neighbours of the s...">SPHHash</a> class to assign them a key. The next step is to calculate our the particles next position with our <a class="el" href="classSPHSolver.html" title="Our solver class used to calculate our new particle positions with SPH equations. ...">SPHSolver</a> class. Once complete we check all the particles for collision class and correct their postion and velocity if this occures. Finally we draw everything in our scene. With drawing I ran into a few problems. One of the viewing modes of the simulation is to be able to view the mesh as it is deformed by the SPH calculations. So this meant firstly I would have do update the normals on the fly, secondly in the shader I had to render any back faces that had shown as front faces. Which I achieved with the following simple peice of code in the fragment shader <br/>
 if(!gl_FrontFacing){<br/>
 newNormal = normal*-1;<br/>
 }<br/>
 else{<br/>
 newNormal = normal;<br/>
 }<br/>
 fragColour=vec4(phongModelHalfVector(),1.0);<br/>
</p>
<p>Sadly this is not a very good solution as the mesh still deformes in a bad way. You will notice it looks very spikey. To imprrove on this I would like to implement a new way of rendering my mesh but for this project I have ran out of time.<br/>
 </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Mar 27 2014 20:22:00 for SPH Water Simulation by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.4 </li>
  </ul>
</div>
</body>
</html>
